# Dockerfile to generate docker image - the base docker image will copy the contents
# from the project root to docker container and generate a binary from it.
#
# Uses multi-stage build to reduce the size of docker image. The second image will use
# the binary generated by the first image

# Global arg to create second build image -- value will be `scratch` or `golang:{{ cookiecutter.go_version }}`
# depending on the build type needed
ARG final_image=scratch

# Can optionally use the Alpine Go image as the base - in general, images built on
# Apline are slimmer, but the variant is not officially support and is highly
# experimental - checkout https://github.com/golang/go/issues/19938 for details.
# Uncomment the line below to switch to the Alpine image as base (and comment the
# out the current base)
#
#           FROM golang:{{ cookiecutter.go_version }}-alpine as builder
FROM golang:{{ cookiecutter.go_version }} as builder

# Setup environmet variables - chores.
ENV GO111MODULE=on \
    CGO_ENABLED=0 \
    GOOS=linux \
    GOARCH=amd64

# Create a build directory if one does not exist, and use it as the work directory
RUN mkdir -p /build
WORKDIR /build

# Copy code into the work directory
COPY . .

# Fetch all required modules, build and install them.
RUN go get -d -v ./...
RUN go install -v ./...

# Generate a compiled binary
RUN go build -v -o {{ cookiecutter.project_name.strip() }}

# Create a new directory named `dist` in the parent, and copy the generated binary in it
RUN mkdir -p ../dist/ && cp -v ./{{ cookiecutter.project_name.strip() }} ../dist


# Second stage - `scratch` for production builds, and `golang:{{ cookiecutter.go_version }}` for debug builds
FROM ${final_image}

# Copy the generated binary from previous image to this one
COPY --from=builder /dist/{{ cookiecutter.project_name.strip() }} .

# Run the binary
CMD ["/{{ cookiecutter.project_name.strip() }}"]
